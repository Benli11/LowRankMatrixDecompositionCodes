Implementations of fast randomized algorithms for computing the approximate low rank SVD of a matrix. 
A \approx U_k \Sigma_k V^T_k
where A is mxn, U_k is mxk, \Sigma_k is kxk, and V_k is nxk, with k << min(m,n).
See the included pdf file (in description/ folder) for a more detailed description.
There are three codes: for single processor (with GNU GSL), multiprocessor 
(with Intel MKL) and GPU (with CULA library for NVIDIA CUDA capable cards).
A simple implementation in Matlab (or Octave) is also provided for illustration purposes.

Written by Sergey Voronin, 2014-2015
Tested with GSL-1.16, icc/mkl 14.03, cuda/cula 6.0

============ summary of installation and usage ==============

One must install the GNU GSL development libraries, Intel MKL (and the intel C compiler), 
NVIDIA CUDA libraries and the CULA Dense packages. 
Please refer to their corresponding documentations.
http://www.gnu.org/software/gsl/
https://software.intel.com/en-us/intel-mkl
https://developer.nvidia.com/cuda-zone
http://www.culatools.com/dense/

For simple illustration of the randomized SVD algorithms, see the Octave implementation.
Each C implementation resides in its own subfolder with a compile.sh file. After 
necessary paths (PATH variable, LD_LIBRARY_PATH) are set for referencing 
gsl, mkl, and cuda/cula, this file 
should be modified to reflect any local system changes and executed to yield the 
driver executable in each case. Paths for mkl are usually set via:
$ source /opt/intel/bin/compilervars.sh intel64
For cuda/cula, source the script nvidia_gpu_cula_code/setup_paths.sh after checking 
that the paths are correct for your system.  

In order to make a test matrix, use the provide make_matrix_binary.m script which can be run 
from Octave or Matlab. Note that this script writes a binary matrix file.

Once the matrix is made one can use any of the drivers to compute the low 
rank SVD. Inside the main loop of the programs one sets the rank k <= min(nrows,ncols).

One can call either algorithm I,II, or III for computing the low rank SVD with each driver.
Each of the codes also has two autorank functions based on version II of the randomized algorithm, 
for use when a good rank k to use is not known in advance.

Sample calling procedure is as follows (similar for all 3 codes).

=======================

// declare matrices
mat *M, *U, *S, *V;

// load matrix M from file
gsl_matrix *M = matrix_load_from_binary_file(mfile);
m = M->nrows; n = M->ncols;

// set svd rank (< min(m,n)) if not using the autorank version
k = 300;

// call random SVD (use one of the five variants)
randomized_low_rank_svd1(M, k, &U, &S, &V);
randomized_low_rank_svd2(M, k, &U, &S, &V);
randomized_low_rank_svd3(M, k, q, s, &U, &S, &V);
randomized_low_rank_svd2_autorank1(M, frac, TOL, &U, &S, &V);
randomized_low_rank_svd2_autorank2(M, blocksize, TOL, &U, &S, &V);

// write results to disk
matrix_write_to_binary_file(U, "data/U.bin");
matrix_write_to_binary_file(S, "data/S.bin");
matrix_write_to_binary_file(V, "data/V.bin");

=======================

Notice that for the multiprocessor OpenMP based code, one can control the number of 
threads used via an environmental variable. For instance, in bash type:
export OMP_NUM_THREADS=6
to use 6 threads. You should use as many threads as there are physical cores for 
best results, but the optimal configuration differs for different systems.

Example run with GPU code

First, make the matrix
$ octave
> more off;
> make_matrix_binary2 
> ls data/A_mat_6kx12k.bin
$

Check to make sure nvidia libs are setup ok:
$ nvidia-smi 

Switch to correct directory
$ cd nvidia_gpu_cula_code 

Source paths to cuda/cula
$ source setup_paths.sh

Compile
$./compile.sh

Run:
$./driver_gpu_nvidia_cula
Initializing CULA
culaVersion is 18000
loading matrix from ../data/A_mat_6kx12k.bin
initializing M of size 6000 by 12000
done..
sizes of M are 6000 by 12000
calling random SVD version 3 with k = 1000
.........
elapsed time: about 13 seconds
normM = 180.600893 ; normU = 31.622777 ; normS = 176.342348 ; normV = 31.622777 ; normP = 176.342348
percent_error between M and U S V^T = 21.587897
$

